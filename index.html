<!DOCTYPE html>
<html lang="en">
<head>
	<title>WebGL canvas</title>
	<meta charset="utf-8" />
	
	<style type="text/css">
		
		body
		{
		xxxbackground-color:	#0ff;
		color:				#000;
		font-family:		"futura-pt",sans-serif;
		margin:				0px;
		padding:			0px;
		overflow:			hidden;
		}
	</style>
</head>
<body>
	<canvas id="glcanvas" width="100" height="100">
		Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
	</canvas>
<script>
		
	window.onload = main;

	function GetRed(Colour)
	{
		let Value = parseInt( Colour.substring(0,2), 16);
		return Value / 255;
	}
	
	function GetGreen(Colour)
	{
		let Value = parseInt( Colour.substring(2,4), 16);
		return Value / 255;
	}
	
	function GetBlue(Colour)
	{
		let Value = parseInt( Colour.substring(4,6), 16);
		return Value / 255;
	}



	function main()
	{
		console.log("main");


		function GetCanvas()
		{
			var canvas = document.getElementById('glcanvas');
			return canvas;
		}

		// Get the WebGL context from the canvas
		try
		{
			var canvas = GetCanvas();
			var gl = canvas.getContext("webgl");
		}
		catch(ex)
		{}//02
		
		if (!gl)
		{
			console.log("Unable to initialize WebGL. Your browser may not support it.");
			return;
		}//03


		function ResizeCanvas()
		{
			console.log("ResizeCanvas");
			var canvas = GetCanvas();
			canvas.width = window.innerWidth;
			//	gr: where did this border come from?
			canvas.height = window.innerHeight+4;
			
			//	change viewport so clip space is -1..1
			//	keep 1:1 ratio
			let size = Math.max( canvas.width, canvas.height );
			gl.viewport(0, 0, size, size);
			
			//	force render in case there's any gaps in animation
			//Render();
		}

		var Time = 0;

		function Render()
		{
			var Uvs = [
				0, 0,
				1, 0,
				0, 1,
				1, 1
			];
			Time += 1.0 / 60.0;
			
			var Colours = [
			'ADFF5FFF',
			'FFF15FFF',
			'FFB25FFF',
			'FF5F83FF',
			'FF5FFFFF',
			'C15FFFFF',
			'865FFFFF',
			'5F8EFFFF',
			'5FD1FFFF',
			'5FFFD1FF',
			];
			
			// Draw the object given a set of 2D points, in this case a square
			drawObject(gl, shaderProgram, 2, Uvs, SdfTexture, HorseTexture, Time, Colours );
		
			//	rener again
			requestAnimationFrame( Render );
		}
		
		
		var VertexShader = `
			attribute vec2 a_position;
			varying vec2 uv;
			void main()
			{
				vec2 Pos2 = mix( vec2(-1,-1), vec2(1,1), a_position );
				gl_Position = vec4(Pos2, 0.0, 1.0);
				uv = vec2( a_position.x, 1.0-a_position.y);
				
				uv.x = mix( 0.0, 1.0, uv.x );
				uv.y = mix( 0.0, 1.0, uv.y );
			}
			`;
		var FragShader = `
			precision highp float;
			uniform float Time;
			varying vec2 uv;
			uniform sampler2D SdfTexture;
			uniform sampler2D HorseTexture;
			uniform int ColourCount;
			uniform vec3 Colour0;
			uniform vec3 Colour1;
			uniform vec3 Colour2;
			uniform vec3 Colour3;
			uniform vec3 Colour4;
			uniform vec3 Colour5;
			uniform vec3 Colour6;
			uniform vec3 Colour7;
			uniform vec3 Colour8;
			uniform vec3 Colour9;

			vec3 GetColour(int Index)
			{
				if ( Index == 0 )	return Colour0;
				if ( Index == 1 )	return Colour1;
				if ( Index == 2 )	return Colour2;
				if ( Index == 3 )	return Colour3;
				if ( Index == 4 )	return Colour4;
				if ( Index == 5 )	return Colour5;
				if ( Index == 6 )	return Colour6;
				if ( Index == 7 )	return Colour7;
				if ( Index == 8 )	return Colour8;
				if ( Index == 9 )	return Colour9;
				if ( Index < 0 )
					return vec3(1,0,1);
				else
					return vec3(0,1,0);
			}
			
			void main()
			{
				float Distance = texture2D( SdfTexture, uv ).a;
				vec3 Colour = texture2D( HorseTexture, uv ).xyz;
				gl_FragColor = vec4(Colour,1);
				
				float BorderDistance = 1.0;
				float EdgeDistance = 0.999;
				if ( Distance >= EdgeDistance )
				{
					float Blur = (Distance-EdgeDistance) / (BorderDistance-EdgeDistance);
					gl_FragColor.xyz = mix( gl_FragColor.xyz, vec3(0,0,0), 1.0-Blur );
				}
				else
				{
					int StripeCount = 11;
					float SpeedSclar = 3.0;
					Distance += Time / SpeedSclar;
					Distance *= float(StripeCount);
					float Stripef = mod( Distance, float(ColourCount-1) );
					int Stripe = int(Stripef);
					gl_FragColor.xyz = GetColour( Stripe );
				}
			}
			`;

		//context = canvas.getContext('2d');

		// resize the canvas to fill browser window dynamically
		window.addEventListener('resize', ResizeCanvas, false);

		// Setup the shader program with the vertex shader and the fragment shader
		var shaderProgram = buildShaderProgram(gl,VertexShader,FragShader);
		gl.useProgram(shaderProgram);

		var SdfUrl = 'http://electric.horse/horse_sdf.png';
		var HorseUrl = 'http://electric.horse/horse.jpg';
		var SdfTexture = loadTexture(gl,SdfUrl);
		var HorseTexture = loadTexture(gl,HorseUrl);

		ResizeCanvas();
		Render();
	}

	// Create a GLSL shader program given:
	// - a WebGL context,
	// - a string for the vertex shader, and
	// - a string for the fragment shader.
	function buildShaderProgram(gl, vertShaderSrc, fragShaderSrc)
	{
		function buildShader(type, source)
		{
			var sh;
			if (type == "fragment")
				sh = gl.createShader(gl.FRAGMENT_SHADER);
			else if (type == "vertex")
				sh = gl.createShader(gl.VERTEX_SHADER);
			else // Unknown shader type
				return null;
			gl.shaderSource(sh, source);
			gl.compileShader(sh);
			// See if it compiled successfully
			if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
				console.log("An error occurred compiling the " + type +
				" shader: " + gl.getShaderInfoLog(sh));
				return null;
			} else { return sh; }
		};
		
		var prog = gl.createProgram();
		gl.attachShader(prog, buildShader('vertex', vertShaderSrc));
		gl.attachShader(prog, buildShader('fragment', fragShaderSrc));
		gl.linkProgram(prog);
		if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
			throw "Could not link the shader program!";
		}
		return prog;
	}
	
	function loadTexture(gl, url)
	{
		const texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture);
		
		// Because images have to be download over the internet
		// they might take a moment until they are ready.
		// Until then put a single pixel in the texture so we can
		// use it immediately. When the image has finished downloading
		// we'll update the texture with the contents of the image.
		const level = 0;
		const internalFormat = gl.RGBA;
		const width = 1;
		const height = 1;
		const border = 0;
		const srcFormat = gl.RGBA;
		const srcType = gl.UNSIGNED_BYTE;
		const pixel = new Uint8Array([255, 0, 255, 255]);  // opaque blue
		gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
		width, height, border, srcFormat, srcType,
		pixel);
		
		const image = new Image();
		image.crossOrigin = "anonymous";
		image.onload = function()
		{
			console.log("Loaded image " + image.src);
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,	srcFormat, srcType, image);
			
			// WebGL1 has different requirements for power of 2 images
			// vs non power of 2 images so check if the image is a
			// power of 2 in both dimensions.
			// No, it's not a power of 2. Turn of mips and set
			// wrapping to clamp to edge
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		};
		
		image.src = url;
		
		return texture;
	}

	// Draw an object given a shader program and a list of vertices
	function drawObject(gl, shaderProgram, coordDimensions, vertexCoords, SdfTexture, HorseTexture, Time, Colours )
	{
		let SdfUniform = gl.getUniformLocation(shaderProgram, 'SdfTexture');
		let HorseUniform = gl.getUniformLocation(shaderProgram, 'HorseTexture');
		let PositionUniform = gl.getAttribLocation(shaderProgram, "a_position");
		let TimeUniform = gl.getUniformLocation(shaderProgram, "Time");

		//	setup textures
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, SdfTexture);
		gl.uniform1i(SdfUniform, 0);
		
		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, HorseTexture);
		gl.uniform1i(HorseUniform, 1);

		let ColourCountUniform = gl.getUniformLocation(shaderProgram, "ColourCount");
		gl.uniform1i(ColourCountUniform, Colours.length);
		
		//	gr; can't use less than with this xml html
		for ( let i=0;	i<Colours.length;	i++ )
		{
			let ColourUniform = gl.getUniformLocation(shaderProgram, "Colour" + i );
			gl.uniform3f(ColourUniform, GetRed(Colours[i]), GetGreen(Colours[i]), GetBlue(Colours[i]) );
		}


		// Create a buffer and put a single clipspace rectangle in it (2 triangles)
		var buffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);// Set this buffer as the current one for the next buffer operations
		// Fill the buffer with the triangles.
		// STATIC_DRAW states that we are only going to write to this buffer very infrequently
		// so the system can optimise for this situation.
		// It doesn't stop us from writing to the buffer again,
		// but it might not be as efficient.
		// See http://stackoverflow.com/q/16462517 for more details.
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexCoords), gl.STATIC_DRAW);
		// Get a reference to the "a_position" variable of the vertex shader,
		// which we'll connect with the 3D vertex data now stored in the current WebGL buffer.
		// Enable the a_position vertex attribute for rendering
		// All client-side capabilities are disabled by default,
		// including all vertex attribute arrays.
		gl.enableVertexAttribArray(PositionUniform);
		// Specify the data structure of the array that will be used to store the vertex position data.
		// The parameters indicate that the vertexPos attribute is:
		// - a list of elements with 2 components each (2D vertices) 
		// - of type gl.Float
		// - and they should be un-normalized.
		// The final two parameters are rarely used.
		// The first specifies the stride of the data i.e. the amount of storage allocated to each element
		// and the second specifies the offset i.e. where the data starts.
		// For standard JavaScript arrays both are set to zero to indicate tight packing and no offset.
		gl.vertexAttribPointer(PositionUniform, coordDimensions, gl.FLOAT, false, 0, 0);
		
		gl.uniform1f(TimeUniform, Time);
		
		// Set black as the background color
		gl.clearColor(0, 0, 0, 1); // defaults to white (1,1,1)
		// Manually clear the canvas.
		gl.clear(gl.COLOR_BUFFER_BIT);
		// draw the array set as current by the bindBuffer() command.
		// - parameter 1: how the vertices are to be grouped into geometric primitives.
		//   TRIANGLES requires a full set of 3 vertices for each triangle,
		//   so the common vertices need to be repeated;
		//   TRIANGLE_STRIP reuses the last 3 vertices, so if the triangles are connected,
		//   this only requires each vertex to be specified once.
		//   See https://www.khronos.org/message_boards/showthread.php/7292-Different-drawArrays-modes-in-WebGL#post23621
		// - Parameter 2: on what index to start
		// - Parameter 3: how many vertices to draw
		gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertexCoords.length/coordDimensions);
	}
</script></body>
</html>
